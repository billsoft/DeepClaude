# 错误步骤记录

## 2025-03-01：数据库模型与表结构不一致问题

### 错误信息
- **现象**：数据库测试失败，出现 "Unknown column 'reasoning' in 'field list'" 错误
- **错误日志**：
  ```
  pymysql.err.OperationalError: (1054, "Unknown column 'reasoning' in 'field list'")
  [SQL: INSERT INTO conversation_history (conversation_id, user_id, `role`, content, create_time, 
  is_error, is_duplicate, tokens, model_name, reasoning) VALUES ...]
  ```
- **影响范围**：所有涉及conversation_history表的操作，包括添加对话历史、查询历史记录等功能

### 错误分析
- **根本原因**：数据库建表脚本中没有定义reasoning字段，但SQLAlchemy模型中定义了该字段，造成模型与实际表结构不一致
- **尝试的方案**：
  1. 考虑修改测试代码，移除reasoning字段：
     - 结果：不可行
     - 原因：reasoning字段在实际业务中有用，用于存储AI的思考过程
  2. 修改数据库表结构，添加reasoning字段：
     - 结果：成功
     - 验证：测试全部通过

### 解决方案
- **最终方案**：创建数据库工具函数，自动检查并添加缺失的列
  ```python
  def add_reasoning_column_if_not_exists():
      # 检查列是否存在
      # 如果不存在则添加
      # 验证添加结果
  ```
- **评估**：
  - 有效性：完全解决（100%）
  - 复杂度：低
  - 资源消耗：低
  - 稳定性：高
  - 兼容性：高

### 经验总结
- **避免方向**：避免模型定义与数据库结构脱节，不应直接假设表结构已与模型一致
- **正确思路**：
  1. 数据库模型变更时同步更新建表脚本
  2. 开发迁移工具检查并修复表结构与模型不一致问题
  3. 在关键启动点（如测试前）检查数据库结构
- **最佳实践**：
  1. 维护数据库变更记录文档
  2. 实现自动化迁移工具
  3. 在应用启动前自动检查表结构
- **预防措施**：
  1. 使用版本化的数据库迁移工具（如Alembic）
  2. 在CI/CD流程中添加数据库结构验证步骤
  3. 开发与测试环境保持同步

## 2024-03-01：工具调用实现问题 [P1]

### 错误信息
- **现象**：工具调用功能无法正常工作，Claude API 没有返回工具调用响应
- **错误日志**：
  ```
  工具调用决策结果: 不使用工具
  Claude API错误: 工具调用参数未正确传递
  ```
- **影响范围**：所有涉及工具调用的功能，包括天气查询、搜索等功能

### 错误分析
- **根本原因**：
  1. Claude API 版本过低，不支持工具调用功能
  2. 工具参数在传递过程中丢失
  3. 工具调用请求格式不符合 Claude API 要求
  4. 工具调用响应处理逻辑不完整

- **尝试的方案**：
  1. 直接传递工具参数到 Claude API：
     - 结果：失败
     - 原因：API 版本不支持工具调用
  
  2. 更新 API 版本但不修改请求格式：
     - 结果：失败
     - 原因：请求格式不符合新版本要求

  3. 完整实现工具调用流程：
     - 结果：成功
     - 验证：测试通过，能正确处理工具调用

### 解决方案
- **最终方案**：
  1. 更新 Claude API 版本到支持工具调用的版本
  ```python
  headers.update({
      "anthropic-version": "2024-02-15",
      "anthropic-beta": "messages-2024-02-15"
  })
  ```
  
  2. 在请求数据中正确添加工具参数
  ```python
  if "tools" in kwargs and kwargs["tools"]:
      data["tools"] = tools
      data["tool_choice"] = tool_choice
  ```
  
  3. 完善工具调用响应处理
  ```python
  if response['type'] == 'tool_calls':
      tool_calls = response.get('tool_calls', [])
      for tool_call in tool_calls:
          yield "tool_call", tool_call
  ```

- **评估**：
  - 有效性：完全解决（100%）
  - 复杂度：中
  - 资源消耗：低
  - 稳定性：高
  - 兼容性：高

### 经验总结
- **避免方向**：
  1. 不要假设 API 版本自动支持新功能
  2. 不要忽略工具参数的验证
  3. 不要在传递过程中丢失参数
  4. 不要忽略错误处理和日志记录

- **正确思路**：
  1. 确保 API 版本支持目标功能
  2. 完整实现工具调用流程
  3. 添加参数验证和错误处理
  4. 增加详细的日志记录

- **最佳实践**：
  1. 在工具调用前验证工具格式
  2. 记录工具调用的完整过程
  3. 实现优雅的错误处理
  4. 保持与 OpenAI API 格式兼容

- **预防措施**：
  1. 添加工具格式验证
  2. 实现完整的日志记录
  3. 添加工具调用测试用例
  4. 定期验证 API 版本兼容性

### 代码示例
- **问题代码**：
```python
# 直接传递未验证的工具参数
data["tools"] = kwargs.get("tools")
```

- **修复代码**：
```python
# 验证并处理工具参数
if "tools" in kwargs and kwargs["tools"]:
    tools = kwargs["tools"]
    for tool in tools:
        if not isinstance(tool, dict) or "function" not in tool:
            logger.warning(f"跳过无效的工具定义: {tool}")
            continue
    data["tools"] = tools
    logger.info(f"添加 {len(tools)} 个工具到请求")
```

- **关键差异**：
  1. 添加了工具格式验证
  2. 增加了日志记录
  3. 优化了错误处理
  4. 完善了参数传递 

#### **2024-03-19 15:30:00 - [TOOL-001] 工具调用格式转换和验证问题 [P2]**
- **标签**：#工具调用 #格式转换 #API兼容性
- **参考**：PARAM-001, API-103

##### **错误信息**
- **现象**：工具调用请求在传递过程中可能丢失或格式不正确
- **影响范围**：所有依赖工具调用的功能
- **复现条件**：
  1. 通过 Dify 发送带工具的请求
  2. 请求中的工具参数未正确传递到 DeepClaude

##### **错误分析**
- **根本原因**：
  1. 工具格式转换可能不完全兼容
  2. 工具验证逻辑可能过于严格
  3. 日志记录不够完整，难以追踪问题

- **尝试的方案**：
  1. 添加详细的请求数据日志：成功
  2. 实现工具格式转换功能：部分成功
  3. 增加工具验证和转换日志：成功

##### **解决方案**
- **最终方案**：
  1. 在入口处添加完整的请求数据日志
  2. 实现工具格式转换功能
  3. 增加工具验证和转换的详细日志
  4. 优化工具验证逻辑

- **评估**：
  - 有效性：部分解决（80%）
  - 复杂度：中
  - 资源消耗：低
  - 稳定性：高
  - 兼容性：中

##### **经验总结**
- **避免方向**：
  1. 避免过于严格的工具验证
  2. 避免在日志中省略关键信息
  3. 避免直接修改工具格式而不验证

- **正确思路**：
  1. 完整记录请求和响应数据
  2. 在关键节点添加详细日志
  3. 实现灵活的工具格式转换
  4. 保持向后兼容性

- **最佳实践**：
  1. 在入口处记录完整请求数据
  2. 在格式转换前后记录工具数据
  3. 使用统一的工具格式规范
  4. 提供详细的错误信息

##### **预防措施**
1. 定期检查日志完整性
2. 测试不同格式的工具调用
3. 验证工具格式转换结果
4. 保持与上游 API 的兼容性 