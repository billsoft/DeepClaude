---
description: 记录错误的历史操作步骤不要重复
globs: *.py
---
# 错误步骤记录规则

## 目的
- 避免重复犯同样的错误
- 系统性积累项目修改经验
- 提高代码质量和开发效率
- 减少无效尝试和调试时间
- 建立有效的学习闭环
- 形成团队知识库和最佳实践

## @history_error_step.md 记录时机
- 每次回答问题前，如发现上次修改步骤有误
- 每次发现程序报错后立即记录
- 发现之前的操作导致了后续问题时
- 尝试多种方案后发现某些方案无效时
- 解决复杂问题后，记录整个解决过程中的关键误区
- 修复一个问题但引入新问题时
- 重构代码后发现兼容性问题时

## @history_error_step.md 查看时机
- 每次回答问题前必须查看
- 思考解决方案过程中反复参考
- 提出修改建议前进行对照
- 遇到相似问题时进行模式匹配
- 制定多步骤解决方案前回顾历史经验
- 修改核心模块或关键功能前
- 引入新依赖或集成新服务前

## 错误严重程度分级系统
- **P0 - 致命错误**：系统完全不可用，阻断所有功能
- **P1 - 严重错误**：核心功能受损，但系统部分可用
- **P2 - 中度错误**：重要功能受影响，但有替代方案
- **P3 - 轻微错误**：次要功能问题，对用户体验有轻微影响
- **P4 - 微小问题**：美观或非功能性问题，不影响使用

## 错误码系统
格式：`[类别前缀]-[三位数字]`

常见类别前缀：
- `PARAM`：参数相关错误
- `AUTH`：认证授权错误
- `STREAM`：流式处理错误
- `API`：API调用错误
- `MODEL`：模型相关错误
- `CONFIG`：配置相关错误
- `ASYNC`：异步处理错误
- `INTEG`：集成相关错误
- `PERF`：性能相关问题

例如：`PARAM-001`、`STREAM-042`、`API-103`

## 记录格式标准
- 标题格式：`YYYY-MM-DD HH:MM:SS - [错误码] 简要错误描述 [P级别]`
- 采用分类组织法，将相似错误归类
- 使用Markdown列表和表格增强可读性
- 添加关键字标签便于快速检索，格式：`标签：#tag1 #tag2`
- 错误ID和引用系统便于交叉参考，格式：`参考：ERROR-001, ERROR-005`

## 记录内容详细要求
1. **错误信息**（必填）
   - 错误现象的准确描述
   - 完整的错误代码/日志（包含行号）
   - 影响范围和严重程度
   - 复现步骤和条件
   - 相关组件和依赖关系

2. **错误分析**（必填）
   - 根本原因分析（RCA）
   - 尝试过的所有解决方案（包括失败的）
   - 每个方案失败的具体原因
   - 成功解决方案的详细步骤
   - 问题解决的证据和验证方法

3. **经验总结**（必填）
   - 错误的本质模式归纳
   - 明确列出需要避免的修改方向
   - 正确的处理思路和最佳实践
   - 可推广到其他场景的经验
   - 预防类似错误的建议

4. **代码示例**（可选）
   - 问题代码片段（使用Markdown代码块）
   - 修复后的代码片段（使用Markdown代码块）
   - 关键差异说明（使用对比注释）

## 解决方案评估标准
1. **有效性**：完全解决（100%）、部分解决（XX%）、未解决（0%）
2. **复杂度**：高（需要大量修改）、中（需要适量修改）、低（简单修改）
3. **资源消耗**：高（需要额外资源）、中（使用现有资源）、低（释放资源）
4. **稳定性**：高（长期解决方案）、中（中期解决方案）、低（临时方案）
5. **兼容性**：高（完全兼容）、中（部分兼容需适配）、低（需大量适配）

## 使用规则
1. **查看规则**：每次修改前必须查看 @history_error_step.md
2. **避免重复**：严格避免使用记录中已失败的思路
3. **持续更新**：发现新的错误模式及时补充记录
4. **归类整理**：定期对错误记录进行分类和模式提取
5. **关联分析**：建立错误之间的关联关系和模式
6. **行动指南**：将总结的经验转化为具体行动指南
7. **收敛迭代**：每次修改应该比上次更接近最终解决方案

## 错误类型分类
1. **接口错误**：参数不匹配、返回值不符合预期
2. **逻辑错误**：条件判断失误、边界情况未处理
3. **并发错误**：异步操作问题、竞态条件
4. **配置错误**：环境变量设置不正确、依赖配置有误
5. **性能问题**：资源使用不当、效率低下
6. **集成问题**：组件间接口不匹配、依赖冲突
7. **安全隐患**：权限控制不当、数据保护不足
8. **兼容性问题**：版本不兼容、API变更影响
9. **状态管理问题**：状态转换错误、状态丢失
10. **资源泄漏**：未释放资源、连接未关闭

## 特定项目错误模式
- **流式输出相关**：SSE格式问题、连接保持问题、数据流转问题
- **API对接相关**：认证错误、格式不匹配、版本不兼容
- **模型参数相关**：参数传递错误、参数冲突、默认值问题
- **异步处理相关**：Promise处理不当、async/await使用错误
- **环境配置相关**：环境变量缺失、配置项冲突、路径错误

## 经验应用与迭代
- 将频繁出现的错误模式提炼为检查清单
- 从错误记录中提取通用的最佳实践
- 根据错误模式调整修改策略和方法
- 定期回顾错误记录，提炼更高层次的经验总结
- 建立错误预防机制，如自动检查、单元测试

## 错误记录模板

```markdown
#### **YYYY-MM-DD HH:MM:SS - [错误码] 简要错误描述 [P级别]**
- **标签**：#标签1 #标签2 #标签3
- **参考**：相关错误ID（如有）

##### **错误信息**
- **现象**：描述错误的具体表现
- **错误日志**：
  ```
  在此粘贴完整错误日志
  ```
- **影响范围**：描述此错误影响的功能或模块
- **复现条件**：描述如何复现此错误

##### **错误分析**
- **根本原因**：分析错误的根本原因
- **尝试的方案**：
  1. 方案一：描述...
     - 结果：失败/部分成功
     - 原因：解释为什么不完全有效
  2. 方案二：描述...
     - 结果：成功
     - 验证：描述如何验证解决方案有效

##### **解决方案**
- **最终方案**：详细描述最终采用的解决方案
- **评估**：
  - 有效性：完全解决（100%）
  - 复杂度：中
  - 资源消耗：低
  - 稳定性：高
  - 兼容性：高

##### **经验总结**
- **避免方向**：列出需要避免的修改思路
- **正确思路**：描述正确的处理方法
- **最佳实践**：提取可以应用到其他场景的经验
- **预防措施**：建议如何预防类似问题

##### **代码示例**（可选）
- **问题代码**：
  ```python
  # 问题代码示例
  ```
- **修复代码**：
  ```python
  # 修复后的代码示例
  ```
- **关键差异**：说明关键修改点及其作用
```

## 实际错误记录示例

```markdown
#### **2024-02-20 22:04:36 - [PARAM-001] Claude客户端参数错误 [P2]**
- **标签**：#参数传递 #API调用 #接口不匹配
- **参考**：PARAM-003, MODEL-002

##### **错误信息**
- **现象**：`ClaudeClient.stream_chat()`接收到意外的`deepseek_model`参数
- **错误日志**：
  ```
  TypeError: ClaudeClient.stream_chat() got an unexpected keyword argument 'deepseek_model'
  File "app/services/clients.py", line 157, in stream_chat
  ```
- **影响范围**：所有依赖Claude API的流式对话功能
- **复现条件**：在DeepClaude中同时配置了Claude和DeepSeek模型时

##### **错误分析**
- **根本原因**：DeepClaude在调用`stream_chat`时传递了不相关的参数，未正确区分思考者和回答者的参数
- **尝试的方案**：
  1. 在ClaudeClient添加参数处理：
     - 结果：失败
     - 原因：违反了单一职责原则，增加了不必要的依赖
  2. 在上层过滤参数：
     - 结果：成功
     - 验证：日志中不再有参数错误，API调用正常

##### **解决方案**
- **最终方案**：区分思考者和回答者的参数，在DeepClaude层过滤参数
  ```python
  # 提取思考者参数
  thinker_kwargs = {k: v for k, v in kwargs.items() 
                   if k in ['model', 'temperature', 'max_tokens']}
  
  # 提取回答者参数
  answerer_kwargs = {k: v for k, v in kwargs.items() 
                    if k not in ['deepseek_model']}
  ```
- **评估**：
  - 有效性：完全解决（100%）
  - 复杂度：低
  - 资源消耗：低
  - 稳定性：高
  - 兼容性：高

##### **经验总结**
- **避免方向**：避免直接传递完整kwargs，避免在下层组件处理上层特定参数
- **正确思路**：在合适的层次处理参数，保持接口清晰
- **最佳实践**：为每个组件定义明确的参数集，避免参数泄漏
- **预防措施**：使用类型提示和接口文档，明确每个方法的参数要求

##### **代码示例**
- **问题代码**：
  ```python
  # 问题：直接传递所有参数
  async def process(self, **kwargs):
      await self.client.stream_chat(**kwargs)  # 错误：传递了不相关参数
  ```
- **修复代码**：
  ```python
  # 解决：过滤参数
  async def process(self, **kwargs):
      # 过滤只有Claude客户端需要的参数
      claude_params = {k: v for k, v in kwargs.items() 
                      if k in self.claude_allowed_params}
      await self.client.stream_chat(**claude_params)
  ```
- **关键差异**：添加了参数过滤，确保只传递目标客户端需要的参数